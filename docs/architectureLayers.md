# Architecture layers

* [Widgets](#widgets)
* [Features](#features)
* [Services](#services)
* [Modules](#modules)

## Widgets

### Definitions

#### Widget

Widget — the major exchange UI element on the trade/classic page with the
following properties:

* has a rectangular form;
* could be resized;
* could be moved;
* has [settings](#widget-settings);
* divided to kinds of the type `WidgetKind`;
* represented by the `IWidget` interface, which accepts interfaces for
  the [widget settings](#widget-settings) and the [widget form
  settings](#widget-settings) as the generic arguments;
* part of the [preset](#preset) structure.

#### Widget settings

Widget settings — all properties of the widget that user can
customize. Widget settings have subset named "widget form settings",
that are all properties of the widget that user customize through the
settings form which is displayed on:

* clicking the gear icon in the upper right corner of the widget;
* adding a widget by clicking to the plus icon in the right part of
  the page header.

Generic widget settings are represented with the `WidgetSettings` type
and generic widget form settings with the `WidgetFormSettings` type,
while settings for a widget of particular kind are represented with
the `I{WidgetKind}Settings` interface and form settings for a widget
of particular kind with the `I{WidgetKind}FormSettings`, where the
`{WidgetKind}` is a widget kind of type `WidgetKind` translated to the
camel case (with the exception to the chart widget).

Widget settings are versioned, which means that there exists a
sequence of versions of widget settings such that each version may (or
may not, because settings are part of the larger versioned structure
named user config) introduce settings with the different properties
compared to settings of the previous version. Transforming of settings
from their previous version to the next one is performed by the
migrators layer.

#### Preset

Preset is the named collection of widgets which determines their position
on the screen.

### Instructions

#### Adding new widget or changing settings of existing

##### 1. Define new interface for widget settings

1.1 In the directory `shared/types/models/widgets/versioned` create a
file named `v{x}.ts`, $`x = last + 1`$, where _last_ is the number of
last version.

File should export two interfaces: `IUserConfig` and
`IVersionedTypes`. `IVersionedTypes` should be generated by
`IGenericVersionedTypes` which accepts `WidgetKind`,
`IWidgetSettingsAssoc`, `IWidgetFormSettingsAssoc`, where:

* `IWidgetSettingsAssoc` is an interface which associates each
  possible `WidgetKind` to its widget settings of this kind;
* `IWidgetFormSettingsAssoc` is an interface which associates each
  possible `WidgetKind` to its widget form settings of this kind.

For example, `IWidgetSettingsAssoc` for the first version looks like:

```ts
interface IWidgetsSettingsAssoc {
  'balance': IBalanceSettings;
  'exchange-rates': IExchangeRatesSettings;
  'order-list': IOrderListSettings;
  'order-history': IOrderHistorySettings;
  'chat': null;
  'chart': IStockChartSettings;
  'order-book': IOrderBookSettings;
  'trade-history': ITradeHistorySettings;
  'place-order': null;
  'operation-history': IOperationHistorySettings;
}
```

where `null` stands for no settings for the given widget.

Each generic argument for `IGenericVersionedTypes` should be extended
or passed directly from `IVersionedTypes` of the previous version.

The `IUserConfig` interface should be also extended from the
`IUserConfig` of the previous version. In our case (adding a new
widget or changing of the settings of existing) we should overwrite
the `version` property since we introduce a new version and the
`presets` property since widget settings are part of the preset
structure. `IPreset` interface should be taken from the new
`IVersionedTypes` interface.

1.2 In `shared/types/models/widgets/versioned/latest` file change a
file name with exports to `./v{x}`. That is exports of the
`IUserConfig` and the `IVersionedTypes` of the latest version.

##### 2. Add migrator

2.1 In the `shared/helpers/migrators/list` directory create a file
named `v{x}.ts`.

File should export an object that implements `IMigrator` interface,
where `IMigrator['migrate']` is the function which receives
`IUserConfig` of the previous version and returns a `IUserConfig` of
the new version;

2.2 In the `shared/helpers/migrators/list/index.ts` file import the
newly implemented migrator and add to the `migrators` array

## Features

A feature is the main unit in the architecture. A feature has its own branch in the redux state, redux logic, and react components which implement a functionality represented by the feature.
A feature can use services, shared components or other features' containers.

### Lazy loading
A feature's content doesn't get imported and used directly. Instead, a dynamic import & webpack chunks are used to provide a feature loading only when the feature is being used in the currently exeucting code, which helps to speed up the application initialization and initial load processes. The details of how it's implemented are listed below.

#### Feature entry
Each feature must have a file called `entry.ts`, containing a *feature entry*, which is basically an object with the data that gets exported by the feature. The entry is created using a shared helper function `makeFeatureEntry`. Entry is the part of the feature which is getting loaded dynamically.
```
import { makeFeatureEntry } from 'shared/helpers/makeFeatureEntry';

import * as containers from './view/containers';
import { actions, selectors, reducer, getSaga } from './redux';

const entry = makeFeatureEntry({
  containers,
  actions,
  selectors,
  widgets: {},
  redux: {
    reducers: { transactions: reducer },
    sagas: [getSaga],
  },
});

type Entry = typeof entry;

export { Entry, entry };
```
#### Feature loader
Each feature must have a file called `loader.ts`, containing a function called `loadEntry` which would import the entry dynamically

```
import { Entry } from './entry';

export function loadEntry(): Promise<Entry> {
  return import('./entry').then(feature => feature.entry);
}
```

Basically there are two cases where features can be loaded and used. These cases are described in the next two  sections.

#### A feature can be used in [modules](#modules)

A feature which is used in a module is loaded using a `featureConnect` HOC. It takes a map with features' loaders (you can also pass a preloader as a second argument and it'll be shown while the entries are loading) and returns a component with features' entries passed as props.

```
import React from 'react';
import * as features from 'features';
import { featureConnect } from 'core';
import block from 'bem-cn';

import AdminLayout from '../AdminLayout/AdminLayout';
import './AssetsLayout.scss';

interface IFeatureProps {
  assetsFeatureEntry: features.assets.Entry;
}

type IProps = IFeatureProps;

const b = block('assets-layout');

class AssetsLayout extends React.PureComponent<IProps> {

  public render() {
    const { assetsFeatureEntry } = this.props;
    return (
      <AdminLayout>
        <div className={b()}>
          <assetsFeatureEntry.containers.AssetsInfoTable />
          <assetsFeatureEntry.containers.EditAsset />
        </div>
      </AdminLayout>
    );
  }
}

export default featureConnect({
  assetsFeatureEntry: features.assets.loadEntry,
})(AssetsLayout);

```

In this example `assetsFeatureEntry` will be loaded only when `AssetsLayout` is being used. `featureConnect` also automatically connects provided features to the redux store.

#### A feature's container can be used in another feature

If a feature need to use another feature's container it is loaded using the `containersProvider` HOC. It works the same way as the `featureConnect`, but:
- it takes an array of container names as the first argument (this way a feature doesn't really know that it's using some other feature, because from its perspective it's just a generic API for getting containers by their name);
- a component returned by `containersProvicer` includes only chosen containers as props and not feature entries with all feature's data;
- `containersProvicer` provides only those containers that are defined in its configuration. If you want to add a new container that `containersProvicer` can provide, then you'll need to extend the configuration as follows:
  1. add a new property to the `IContainerTypes` interface;
  2. add a new property to the `containerLoadersDictionary` object.


For example, `SomeFeatureComponent.tsx` may look like:
```
import * as firstLazyFeature from 'features/firstLazyFeature';
import * as secondLazyFeature from 'features/secondLazyFeature';

interface IContainerTypes {
  ContainerFromFirstFeature: firstLazyFeature.Entry['containers']['ContainerFromFirstFeature'];
  ContainerFromSecondFeature: secondLazyFeature.Entry['containers']['ContainerFromSecondFeature'];
}

const containerLoadersDictionary: LoadersMap = {
  ContainerFromFirstFeature: firstLazyFeature.loadEntry,
  ContainerFromSecondFeature: secondLazyFeature.loadEntry,
};

...

export { IContainerTypes };
```

and it can be used like:
```
import * as React from 'react';
import { IContainerTypes, containersProvider } from 'core';

interface IProps {
  ContainerFromFirstFeature: IContainerTypes['ContainerFromFirstFeature'];
  ContainerFromSecondFeature: IContainerTypes['ContainerFromSecondFeature'];
}

class SomeFeatureComponent extends React.PureComponent<IProps> {
  public render() {
    const { ContainerFromFirstFeature, ContainerFromSecondFeature } = this.props;

    return (
      <div>
        <ContainerFromFirstFeature />
        <ContainerFromSecondFeature />
      </div>
    );
  }
}

export default (
  containersProvider(['ContainerFromFirstFeature', 'ContainerFromSecondFeature'], <Preloader />)(
    SomeFeatureComponent,
  )
);
```

### Multi-instance feature

Each feature has its own branch in the redux state. But sometimes multiple features on the same page are required. In that case one can use a multi-instance feature.

A state for a multi-feature instance, instead of being stored directly in the app state by the feature name key, like this:

```
{
  ...app state,
  [featureName]: featureState,
}
```
is now stored using an assigned to the feature instance unique ID (also called `instanceKey`):
```
{
  ...app state,
  [featureName]: {
    [featureInstanceID]: featureInstanceState,
    [anotherFeatureInstanceID]: anotherFeatureInstanceState,
    ...and so on
  }
}
```
**How to use a multi-instance feature:**
1. Wrap a feature's state with the IMultiInstanceState interface inside the IAppReduxState interface.
   ```
   export interface IAppReduxState {
    ...
    stockChartWidget: IMultiInstanceState<features.stockChart.namespace.IReduxState>;
   }
   ```
   That would transform the feature state from it's regular form to the multi-instance feature state form (as shown in the example above).

2. Write selectors for a multi-instance feature  with the feature state as its argument instead of the app state.
   ```
   import * as NS from '../namespace';

   export function selectChartData(state: NS.IReduxState): IChartItem[] {
     return state.data.history;
   }
   ```
   Action creators are written as usual.

3. Use the `multiConnect` HOC instead of the regular redux `connect`. `multiConnect` takes the following arguments:
   - path to the feature state (array of strings);
   - initial feature state;
   - mapStateToProps function (the first argument is the feature state, as the multi-instance feature selectors are taking the feature state as its argument instead of the app state; the other arguments are the same as in the regular `connect`, starting from appState);
    ```
    function mapStateToProps(state: IReduxState, appState: IAppReduxState): IStateProps {
      return {
        chartData: selectors.selectChartData(state),
        currentCandle: selectors.selectCurrentCandle(state),
        uiTheme: configSelectors.selectUITheme(appState),
      };
    }
    ```
   - mapDispatchToProps function (written just like for the regular `connect`);

   A component wrapped with `multiConnect` also have the `instanceKey` prop. If you want to make use of it you should use the `IMultiConnectProps` in props type. `instanceKey` is either generated automatically by the `multiConnect` or passed explicitly to the component in case you need multiple containers to use the same redux state branch.

4. In order to diffirentiate between redux actions dispatched from the feature instances, multi-instance feature actions are dispached with the `_instanceKey` field. The field is added automatically by the `multiConnect` HOC so you don't have to worry about that. But the feature reducer have to be configured separately to react on the actions with the `_instanceKey` field. To do that use a `multiReducer` function to wrap a regular feature reducer:
   ```
   export default (
    multiReducer(
      combineReducers({
        data: dataReducer,
        edit: editReducer,
        communication: communicationReducer,
      }),
    )
   );
   ```
5. If you dispatch actions is saga, then you should add the `_instanceKey` to them explicitly and extend IMultiAction when declaring the action interface (it can be found in the action caught by saga):
  ```
  interface ILoadCities extends IMultiAction {
    type: 'SELECT_GEO:LOAD_CITIES';
    payload: IGeoCountry;
  }

  type ILoadCities<T = 'SELECT_GEO:LOAD_CITIES'> = IAction<T, IGeoCountry> & IMultiAction<T>

  function* loadCities({ api }: IDependencies, { payload: country, _instanceKey }: ILoadCities) {
    try {
      const cities: IGeoCity[] = yield call(api.geo.loadCities, country);
      yield put({ ...actions.loadCitiesSuccess(cities), _instanceKey });
    } catch (error) {
      const msg = getMessage(error);
      yield put({ ...actions.loadCitiesFail(msg), _instanceKey });
    }
  }
  ```

## Services

A service is a standalone functionality unit that can be used in [modules](#modules) and [features](#features).

You need to create a service if there is some functionality that can or will be used independently by different parts of the appliation, for example:
 - i18n service used for translation in the whole application;
 - user service provides user-specific data and user-related functionality like loading user balances, documents etc;
 - config service provides the app config and a functionality for saving and loading config, changing theme etc.

Service also can encapsulate a work with side-effects, like API calls to the server or working with local storage.

**A service should know nothing about features and modules**.

A service can contain:

- redux logic (own branch in state, own action creators, a reducer and possibly sagas);
- classes that encapsulate some service-related logic (api calls, sockets, local storage, etc.);
- react containers;
- react Higher-Order Components (HOC) that can encapsulate a work with service classes, pass through props to wrapped containers or control a rendering of wrapped containers depending on a service state;

Example:

```
The i18n service contains:

- redux logic for getting and storing translations;
- a functionality that allows you to switch between app languages;
- a class that updates the tranlsation function and notifies subscribers that a language was changed;
- a HOC, that passes the translation function to a wrapped component as a prop, and rerenders the component after the language switching.
```

## Modules

A module represents different "pages" of the application which are connected in their meaning and purpose, and which routes are built from the same root route. A module can have redux logic and react components.

For example, a module `Auth` combines application parts connected to the users authentication: login, register, repeat password, terms of service, change password and other pages.

```
import * as React from 'react';
import { Route, Switch, Redirect } from 'react-router-dom';
import { compose } from 'redux';

import { routes } from './constants';
import { Module } from '../../shared/types/app';
import {
  ChangePasswordLayout, ConfirmEmailLayout, LogoutLayout, TermsOfServiceLayout,
  ThankYouLayout,
} from './view/containers';
import { layouts } from './view/layouts';

class AuthModule extends Module {
  public getRoutes() {
    return [
      (
        <Route key={routes.auth.getElementKey()} path={routes.auth.getPath()}>
          <Switch>
            <Route
              key={routes.auth.login.getElementKey()}
              path={routes.auth.login.getPath()}
              component={layouts[routes.auth.login.getPath()]}
            />
            <Route
              key={routes.auth.register.getElementKey()}
              path={routes.auth.register.getPath()}
              component={layouts[routes.auth.register.getPath()]}
            />
            <Route
              key={routes.auth['reset-password'].getElementKey()}
              path={routes.auth['reset-password'].getPath()}
              component={layouts[routes.auth['reset-password'].getPath()]}
            />
            <Route
              key={routes.auth['thank-you'].getElementKey()}
              path={routes.auth['thank-you'].getPath()}
              component={ThankYouLayout}
            />
            <Route
              key={routes.auth.tos.getElementKey()}
              path={routes.auth.tos.getPath()}
              component={TermsOfServiceLayout}
            />
            <Route
              key={routes.auth.logout.getElementKey()}
              path={routes.auth.logout.getPath()}
              component={LogoutLayout}
            />
            <Route
              key={routes.auth['confirm-email'].getElementKey()}
              path={routes.auth['confirm-email'].getPath()}
              component={ConfirmEmailLayout}
            />
            <Route
              key={routes.auth['restore-password'].getElementKey()}
              path={routes.auth['restore-password'].getPath()}
              component={ChangePasswordLayout}
            />
            <Redirect exact from={routes.auth.getPath()} to={routes.auth.login.getPath()} />
          </Switch>
        </Route>
      ),
    ];
  }
}

export default AuthModule;
```

Each Layout component of the module is bound to the route and therefore represents an application page. The main building blocks of a Layout component are feature containers:
```
import * as React from 'react';
import { bind } from 'decko';
import { RouteComponentProps } from 'react-router';

import { featureConnect } from 'core';
import * as authFeature from 'features/auth';
import { routes as tradeRoutes } from 'modules/Trade';

interface IFeatureProps {
  authFeatureEntry: authFeature.Entry;
}

type IProps = IFeatureProps & RouteComponentProps<void>;

class TermsOfServiceLayout extends React.PureComponent<IProps> {
  public render() {
    const { authFeatureEntry } = this.props;
    return (
      <authFeatureEntry.containers.TermsOfService
        onSuccesfulTermsAccept={this.handleSuccesfulTermsAccept}
      />
    );
  }

  @bind
  private handleSuccesfulTermsAccept() {
    this.props.history.push(tradeRoutes.trade.classic.getPath());
  }
}

export default featureConnect({
  authFeatureEntry: authFeature.loadEntry,
})(TermsOfServiceLayout);
```

## Shared

The `shared` folder contains a code which is used accross the whole application and isn't tied up with a particular feature, service, module or anything else. Shared code doesn't know anything about the rest of the application. It contains various constants, helper functions, types, and shared react components like Button, Table, Calendar etc.
